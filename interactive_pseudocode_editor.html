            if (item.children && item.children.length > 0) {
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'subsection';
                
                item.children.forEach((child, childIndex) => {
                    const childElement = createItemElement(child, sectionKey, childIndex, itemIndex);
                    childrenDiv.appendChild(childElement);
                });

                // Add "Add Child Item" button
                const addChildButton = document.createElement('div');
                addChildButton.className = 'add-item';
                addChildButton.onclick = () => addChildItem(sectionKey, itemIndex);
                addChildButton.innerHTML = `
                    <i class="fas fa-plus"></i>
                    <span>Add Child Item</span>
                `;
                childrenDiv.appendChild(addChildButton);

                itemDiv.appendChild(childrenDiv);
            }

            return itemDiv;
        }

        // Toggle section visibility
        function toggleSection(sectionKey) {
            const header = document.querySelector(`#section-${sectionKey.replace(/\s+/g, '-')} .section-header`);
            const content = document.getElementById(`content-${sectionKey.replace(/\s+/g, '-')}`);
            
            header.classList.toggle('expanded');
            content.classList.toggle('expanded');
            
            // Update expanded sections set
            const sectionId = `section-${sectionKey.replace(/\s+/g, '-')}`;
            if (header.classList.contains('expanded')) {
                expandedSections.add(sectionId);
            } else {
                expandedSections.delete(sectionId);
            }
        }

        // Smooth update for individual items without full re-render
        function updateItemInPlace(sectionKey, itemIndex, parentIndex = null) {
            let item;
            if (parentIndex !== null) {
                item = pseudocodeData[sectionKey].items[parentIndex].children[itemIndex];
            } else {
                item = pseudocodeData[sectionKey].items[itemIndex];
            }
            
            // Find the existing item element and update it
            const sectionElement = document.getElementById(`section-${sectionKey.replace(/\s+/g, '-')}`);
            const itemElements = sectionElement.querySelectorAll('.item');
            
            // For now, we'll do a targeted re-render of just the section
            const sectionData = pseudocodeData[sectionKey];
            const newSectionElement = createSectionElement(sectionKey, sectionData);
            
            // Preserve expanded state
            const oldHeader = sectionElement.querySelector('.section-header');
            const newHeader = newSectionElement.querySelector('.section-header');
            const newContent = newSectionElement.querySelector('.section-content');
            
            if (oldHeader.classList.contains('expanded')) {
                newHeader.classList.add('expanded');
                newContent.classList.add('expanded');
            }
            
            // Replace the section
            sectionElement.parentNode.replaceChild(newSectionElement, sectionElement);
        }

        // Add new item with smooth update
        function addItem(sectionKey, parentIndex = null, event = null) {
            if (event) event.stopPropagation();
            
            currentSection = sectionKey;
            currentSubsection = parentIndex;
            currentEditingItem = null;
            
            document.getElementById('modalTitle').textContent = 'Add New Item';
            document.getElementById('itemText').value = '';
            document.getElementById('itemPriority').value = 'medium';
            document.getElementById('itemType').value = 'feature';
            document.getElementById('itemDescription').value = '';
            
            document.getElementById('itemModal').style.display = 'block';
            
            // Focus on the text input for better UX
            setTimeout(() => {
                document.getElementById('itemText').focus();
            }, 100);
        }

        // Add child item with smooth update
        function addChildItem(sectionKey, parentIndex) {
            currentSection = sectionKey;
            currentSubsection = parentIndex;
            currentEditingItem = null;
            
            document.getElementById('modalTitle').textContent = 'Add Child Item';
            document.getElementById('itemText').value = '';
            document.getElementById('itemPriority').value = 'medium';
            document.getElementById('itemType').value = 'feature';
            document.getElementById('itemDescription').value = '';
            
            document.getElementById('itemModal').style.display = 'block';
            
            // Focus on the text input for better UX
            setTimeout(() => {
                document.getElementById('itemText').focus();
            }, 100);
        }

        // Edit item with smooth update
        function editItem(sectionKey, itemIndex, parentIndex = null, event = null) {
            if (event) event.stopPropagation();
            
            currentSection = sectionKey;
            currentSubsection = parentIndex;
            currentEditingItem = itemIndex;
            
            let item;
            if (parentIndex !== null) {
                item = pseudocodeData[sectionKey].items[parentIndex].children[itemIndex];
            } else {
                item = pseudocodeData[sectionKey].items[itemIndex];
            }
            
            document.getElementById('modalTitle').textContent = 'Edit Item';
            document.getElementById('itemText').value = item.text;
            document.getElementById('itemPriority').value = item.priority;
            document.getElementById('itemType').value = item.type;
            document.getElementById('itemDescription').value = item.description || '';
            
            document.getElementById('itemModal').style.display = 'block';
            
            // Focus and select text for easier editing
            setTimeout(() => {
                const textInput = document.getElementById('itemText');
                textInput.focus();
                textInput.select();
            }, 100);
        }

        // Delete item with smooth update
        function deleteItem(sectionKey, itemIndex, parentIndex = null, event = null) {
            if (event) event.stopPropagation();
            
            if (confirm('Are you sure you want to delete this item?')) {
                if (parentIndex !== null) {
                    pseudocodeData[sectionKey].items[parentIndex].children.splice(itemIndex, 1);
                } else {
                    pseudocodeData[sectionKey].items.splice(itemIndex, 1);
                }
                
                // Update only the affected section instead of full re-render
                updateItemInPlace(sectionKey, itemIndex, parentIndex);
                updateStats();
                
                // Show success message
                showToast('Item deleted successfully', 'success');
            }
        }

        // Show toast notification
        function showToast(message, type = 'info') {
            // Create toast element
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 6px;
                color: white;
                font-weight: 500;
                z-index: 10000;
                opacity: 0;
                transition: opacity 0.3s ease;
                max-width: 300px;
            `;
            
            // Set background color based on type
            const colors = {
                success: '#28a745',
                error: '#dc3545',
                warning: '#ffc107',
                info: '#007acc'
            };
            toast.style.backgroundColor = colors[type] || colors.info;
            toast.textContent = message;
            
            // Add to page
            document.body.appendChild(toast);
            
            // Fade in
            setTimeout(() => {
                toast.style.opacity = '1';
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        // Expand all sections
        function expandAll() {
            document.querySelectorAll('.section-header').forEach(header => {
                header.classList.add('expanded');
                const sectionId = header.closest('.section').id;
                expandedSections.add(sectionId);
            });
            document.querySelectorAll('.section-content').forEach(content => {
                content.classList.add('expanded');
            });
        }

        // Collapse all sections
        function collapseAll() {
            document.querySelectorAll('.section-header').forEach(header => {
                header.classList.remove('expanded');
                const sectionId = header.closest('.section').id;
                expandedSections.delete(sectionId);
            });
            document.querySelectorAll('.section-content').forEach(content => {
                content.classList.remove('expanded');
            });
        }

        // Close modal
        function closeModal() {
            document.getElementById('itemModal').style.display = 'none';
        }

        // Handle form submission with better UX
        document.getElementById('itemForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const newItem = {
                text: document.getElementById('itemText').value,
                priority: document.getElementById('itemPriority').value,
                type: document.getElementById('itemType').value,
                description: document.getElementById('itemDescription').value
            };
            
            let actionMessage = '';
            
            if (currentEditingItem !== null) {
                // Edit existing item
                if (currentSubsection !== null) {
                    pseudocodeData[currentSection].items[currentSubsection].children[currentEditingItem] = newItem;
                } else {
                    pseudocodeData[currentSection].items[currentEditingItem] = newItem;
                }
                actionMessage = 'Item updated successfully';
            } else {
                // Add new item
                if (currentSubsection !== null) {
                    // Add as child
                    if (!pseudocodeData[currentSection].items[currentSubsection].children) {
                        pseudocodeData[currentSection].items[currentSubsection].children = [];
                    }
                    pseudocodeData[currentSection].items[currentSubsection].children.push(newItem);
                } else {
                    // Add as main item
                    pseudocodeData[currentSection].items.push(newItem);
                }
                actionMessage = 'Item added successfully';
            }
            
            // Update only the affected section for better performance
            updateItemInPlace(currentSection, currentEditingItem, currentSubsection);
            updateStats();
            closeModal();
            
            // Show success message
            showToast(actionMessage, 'success');
        });

        // Search functionality with better UX
        function searchPseudocode(query) {
            const items = document.querySelectorAll('.item');
            let visibleCount = 0;
            
            items.forEach(item => {
                const text = item.querySelector('.item-text').textContent.toLowerCase();
                if (text.includes(query.toLowerCase()) || query === '') {
                    item.style.display = 'flex';
                    visibleCount++;
                } else {
                    item.style.display = 'none';
                }
            });
            
            // If searching, expand all sections to show results
            if (query.trim() !== '') {
                expandAll();
                // Show search results count
                if (visibleCount === 0) {
                    showToast('No items found matching your search', 'warning');
                } else {
                    showToast(`Found ${visibleCount} items matching "${query}"`, 'info');
                }
            }
        }

        // Update statistics
        function updateStats() {
            let totalItems = 0;
            let criticalItems = 0;
            let uxDecisions = 0;
            
            function countItems(items) {
                items.forEach(item => {
                    totalItems++;
                    if (item.priority === 'critical') criticalItems++;
                    if (item.type === 'ux-decision') uxDecisions++;
                    if (item.children) countItems(item.children);
                });
            }
            
            Object.values(pseudocodeData).forEach(section => {
                countItems(section.items);
            });
            
            document.getElementById('totalItems').textContent = totalItems;
            document.getElementById('criticalItems').textContent = criticalItems;
            document.getElementById('uxDecisions').textContent = uxDecisions;
        }

        // Export pseudocode
        function exportPseudocode() {
            const dataStr = JSON.stringify(pseudocodeData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'mit-lms-pseudocode.json';
            link.click();
        }

        // Show statistics
        function showStats() {
            alert(`
Pseudocode Statistics:
- Total Items: ${document.getElementById('totalItems').textContent}
- Critical Items: ${document.getElementById('criticalItems').textContent}
- UX Decisions: ${document.getElementById('uxDecisions').textContent}
- Sections: ${Object.keys(pseudocodeData).length}
            `);
        }

        // Show all sections
        function showAllSections() {
            document.getElementById('breadcrumbPath').textContent = '';
            renderPseudocode();
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('itemModal');
            if (event.target === modal) {
                closeModal();
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initializePseudocode);
    </script>
</body>
</html>
